---
title: 'ACE 的土鳖 bug  不能设置线程栈大小'
author: kxn
type: post
date: 2005-12-09T13:28:23+00:00
url: /index.php/archives/21
views:
  - 2935
categories:
  - Coding
  - Tech Notes

---
　　发现用 ACE 写的多线程程序随便就占用了上百兆内存，查看 /proc/<pid>/maps 发现有很多 10M 大的内存段，用 gdb attach 上去，p 一下 $esp 可以确定那些 10M 的内存段就是线程栈。这怎么可以，我用不到这多堆栈的。于是按照 ACE 的文档设定了线程栈大小，结果发现还是没有效果 @_@

　　读了一下 ACE 的代码，发现原来是 ACE 的一个 bug, ACE 里面创建线程最后是通过 ACE\_OS::thr\_create 函数来创建的，该函数里面关于 stack size 的处理代码如下：  
OS\_NS\_Thread.cpp:2288

> \# if defined (ACE\_HAS\_PTHREAD_SETSTACK)  
> if ((stacksize != 0) && (stack != 0))  
> \# else  
> if (stacksize != 0)  
> \# endif /\* ACE\_HAS\_PTHREAD_SETSTACK \*/  
> {  
> size_t size = stacksize;
> 
> \# if defined (PTHREAD\_STACK\_MIN)  
> if (size < ACE\_static\_cast (size\_t, PTHREAD\_STACK\_MIN)) size = PTHREAD\_STACK\_MIN; # endif /\* PTHREAD\_STACK\_MIN \*/ # if !defined (ACE\_LACKS\_THREAD\_STACK\_SIZE) // JCEJ 12/17/96 # if defined (ACE\_HAS\_PTHREADS\_DRAFT4) || defined (ACE\_HAS\_PTHREADS\_DRAFT6) if (::pthread\_attr\_setstacksize (&attr, size) != 0) # else # if defined (ACE\_HAS\_PTHREAD\_SETSTACK) if (ACE\_ADAPT\_RETVAL(pthread\_attr\_setstack (&attr, stack, size), result) == -1) # else if (ACE\_ADAPT\_RETVAL(pthread\_attr\_setstacksize (&attr, size), result) == -1) # endif /\* ACE\_HAS\_PTHREAD\_SETSTACK \*/ # endif /\* ACE\_HAS\_PTHREADS\_DRAFT4, 6 \*/ { # if defined (ACE\_HAS\_PTHREADS\_DRAFT4) ::pthread\_attr\_delete (&attr); # else /\* ACE\_HAS\_PTHREADS\_DRAFT4 \*/ ::pthread\_attr\_destroy (&attr); # endif /\* ACE\_HAS\_PTHREADS\_DRAFT4 \*/ return -1; } # else ACE\_UNUSED\_ARG (size); # endif /\* !ACE\_LACKS\_THREAD\_STACK_SIZE \*/ }

在 linux 下面编译时候，ACE\_HAS\_PTHREAD\_SETSTACK　会被定义，于是设置线程栈参数会通过 ::pthread\_attr\_setstack 来设置，如果我并不想指定 stack 的地址，只设置默认 stack 的大小，ACE 代码也会通过 ::pthread\_attr_setstack , 但是这个函数如果不指定 stack 地址的话，就忽略了 stacksize 。

最后用了比较垃圾的解决方案，在这段代码前面 #undef 掉 ACE\_HAS\_PTHREAD\_SETSTACK　，这样设置就会通过 ::pthread\_attr_setstacksize 来作，于是就有效了。。</pid>